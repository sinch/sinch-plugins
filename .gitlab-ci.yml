# yaml-language-server: $schema=https://gitlab.com/gitlab-org/gitlab/-/raw/master/app/assets/javascripts/editor/schema/ci.json
# ================================
# GitLab CI Variables Reference
# ================================
# Required variables (set in Settings â†’ CI/CD â†’ Variables):
#   GITHUB_PAT_2 - Personal Access Token with for synching with GitHub repos (MUST be kept secret)
#   GITHUB_REPO_URL - GitHub repository URL (e.g., github.com/sinch/sinch-plugins or https://github.com/sinch/sinch-plugins)
#
# Predefined GitLab CI variables (automatically available):
#   CI_COMMIT_SHORT_SHA   - Short commit SHA (first 8 chars)
#   CI_COMMIT_REF_NAME    - Branch or tag name
#   CI_COMMIT_REF_SLUG    - Branch name slugified for URLs
#   CI_COMMIT_TAG         - Git tag (if pipeline triggered by tag)
#   GITLAB_USER_EMAIL     - Email of user who triggered pipeline
#   GITLAB_USER_NAME      - Name of user who triggered pipeline
#   CI_PROJECT_URL        - GitLab project URL
#   CI_JOB_ID             - Unique job ID
#   CI_JOB_TOKEN          - GitLab job token (used for git authentication)
#   CI_SERVER_HOST        - GitLab server hostname (e.g., gitlab.com)
#   CI_PROJECT_PATH       - Project path (group/project)
# ================================
# Pipeline-level inputs specification
spec:
  inputs:
    version_bump_type:
      description: "Select which version bump to apply. Version bump type: patch (0.0.X), minor (0.X.0), major (X.0.0), or none (skip bump)"
      type: string
      default: "patch"
      options:
        - patch
        - minor
        - major
        - none
    release_tag_override:
      description: "Optional: explicit tag to publish/republish (e.g., sinch-claude-plugin-v0.0.2)."
      type: string
      default: ""
    release_version_override:
      description: "Optional: explicit version to publish/republish (e.g., 0.0.2). Used to compute tag if release_tag_override is empty."
      type: string
      default: ""
---
default:
  tags:
    - saas
    - general
    - eu-west-1
    # Arch is especially important
    - arm64

variables:
  # Make the pipeline input available in `rules:` and `script:` blocks.
  VERSION_BUMP_TYPE: $[[ inputs.version_bump_type ]]
  RELEASE_TAG_OVERRIDE: $[[ inputs.release_tag_override ]]
  RELEASE_VERSION_OVERRIDE: $[[ inputs.release_version_override ]]

stages:
  - pre-release
  - github-sync
  - release

# ================================
# Stage 1 - Bump Version
# ================================
version-bump:
  stage: pre-release
  image: alpine:latest
  before_script:
    - apk add --no-cache git jq
    - |
      echo "ðŸ” Configuring Git authentication..."
      git config --global user.email "${GITLAB_USER_EMAIL:-ci@sinch.com}"
      git config --global user.name "${GITLAB_USER_NAME:-CI Release Bot}"
  script:
    - BUMP_TYPE="$VERSION_BUMP_TYPE"
    - echo "Bump type is $BUMP_TYPE"
    - |
      if [ "$BUMP_TYPE" = "none" ]; then
        echo "Skipping version bump; computing release context for republish"

        PLUGIN_FILE="plugins/sinch-claude-plugin/.claude-plugin/plugin.json"
        TAG_PREFIX="sinch-claude-plugin-v"

        # Ensure we can read from default branch even if this is a web pipeline.
        git fetch --prune --tags origin "$CI_DEFAULT_BRANCH" || true

        TAG_NAME=""
        NEW_VERSION=""

        if [ -n "${RELEASE_TAG_OVERRIDE:-}" ]; then
          TAG_NAME="$RELEASE_TAG_OVERRIDE"
        fi

        if [ -n "${RELEASE_VERSION_OVERRIDE:-}" ]; then
          NEW_VERSION="$RELEASE_VERSION_OVERRIDE"
        fi

        if [ -z "$TAG_NAME" ] && [ -n "${CI_COMMIT_TAG:-}" ]; then
          TAG_NAME="$CI_COMMIT_TAG"
        fi

        # Derive NEW_VERSION from tag if possible.
        if [ -z "$NEW_VERSION" ] && [ -n "$TAG_NAME" ]; then
          case "$TAG_NAME" in
            ${TAG_PREFIX}*) NEW_VERSION="${TAG_NAME#${TAG_PREFIX}}" ;;
          esac
        fi

        # Otherwise read version from default branch plugin.json (no bump).
        if [ -z "$NEW_VERSION" ] || [ "$NEW_VERSION" = "null" ]; then
          DEFAULT_JSON="$(git show "origin/$CI_DEFAULT_BRANCH:$PLUGIN_FILE" 2>/dev/null || cat "$PLUGIN_FILE")"
          NEW_VERSION="$(echo "$DEFAULT_JSON" | jq -r .version)"
        fi

        if [ -z "$TAG_NAME" ]; then
          TAG_NAME="${TAG_PREFIX}${NEW_VERSION}"
        fi

        if [ -n "${RELEASE_TAG_OVERRIDE:-}" ] && [ -n "${RELEASE_VERSION_OVERRIDE:-}" ]; then
          if [ "$TAG_NAME" != "${TAG_PREFIX}${NEW_VERSION}" ]; then
            echo "ERROR: RELEASE_TAG_OVERRIDE and RELEASE_VERSION_OVERRIDE disagree."
            exit 1
          fi
        fi

        if [ -z "$NEW_VERSION" ] || [ "$NEW_VERSION" = "null" ] || [ -z "$TAG_NAME" ]; then
          echo "ERROR: unable to compute NEW_VERSION/TAG_NAME for republish."
          exit 1
        fi

        RELEASE_COMMIT_SHA=""
        if git ls-remote --exit-code --tags origin "refs/tags/$TAG_NAME" > /dev/null 2>&1; then
          git fetch --tags origin || true
          RELEASE_COMMIT_SHA="$(git rev-list -n 1 "$TAG_NAME" 2>/dev/null || true)"
        fi

        {
          echo "NEW_VERSION=${NEW_VERSION}";
          echo "TAG_NAME=${TAG_NAME}";
          if [ -n "$RELEASE_COMMIT_SHA" ]; then echo "RELEASE_COMMIT_SHA=${RELEASE_COMMIT_SHA}"; fi
        } > release.env
        exit 0
      fi

    # Set up Git credentials using GitLab's CI_JOB_TOKEN with write access
    # Note: Requires Settings -> CI/CD -> Job Token Permissions -> Allow Git push requests to the repository
    - |
      git remote set-url origin "https://gitlab-ci-token:${CI_JOB_TOKEN}@${CI_SERVER_HOST}/${CI_PROJECT_PATH}.git"
      git checkout $CI_COMMIT_REF_NAME
      git pull origin $CI_COMMIT_REF_NAME

    - PLUGIN_FILE="plugins/sinch-claude-plugin/.claude-plugin/plugin.json"
    - CURRENT_VERSION=$(jq -r .version $PLUGIN_FILE)
    - echo "Current version $CURRENT_VERSION"

    - |
      major=$(echo "$CURRENT_VERSION" | cut -d. -f1)
      minor=$(echo "$CURRENT_VERSION" | cut -d. -f2)
      patch=$(echo "$CURRENT_VERSION" | cut -d. -f3)
      if [ "$BUMP_TYPE" = "major" ]; then
        major=$((major + 1)); minor=0; patch=0
      elif [ "$BUMP_TYPE" = "minor" ]; then
        minor=$((minor + 1)); patch=0
      else
        patch=$((patch + 1))
      fi
      NEW_VERSION="$major.$minor.$patch"
      echo "New version: $NEW_VERSION"
      echo "$NEW_VERSION" > version.txt

    - NEW_VERSION=$(cat version.txt)
    - jq --arg v "$NEW_VERSION" '.version = $v' $PLUGIN_FILE > tmp.json && mv tmp.json $PLUGIN_FILE

    - git add $PLUGIN_FILE
    - |
      git commit -m "ci(release): ${NEW_VERSION} [skip ci]"

      RELEASE_COMMIT_SHA="$(git rev-parse HEAD)"
      TAG_NAME="sinch-claude-plugin-v${NEW_VERSION}"
      {
        echo "NEW_VERSION=${NEW_VERSION}";
        echo "TAG_NAME=${TAG_NAME}";
        echo "RELEASE_COMMIT_SHA=${RELEASE_COMMIT_SHA}";
      } > release.env

      git push origin HEAD:$CI_COMMIT_REF_NAME
  artifacts:
    reports:
      dotenv: release.env
  rules:
    - if: $CI_COMMIT_REF_NAME == $CI_DEFAULT_BRANCH && $CI_PIPELINE_SOURCE == "push"
    - if: $CI_COMMIT_REF_NAME == $CI_DEFAULT_BRANCH && $CI_PIPELINE_SOURCE == "web"

# ================================
# Stage 2 - Sync default branch to GitHub
# ================================
# We only using git push [$CI_DEFAULT_BRANCH] --force here instead of a full mirror push to avoid
# cloning internal branches or tags that are not meant to be pushed to GitHub.
sync_to_github:
  stage: github-sync
  image:
    name: alpine/git:latest
    entrypoint: [""]
  needs:
    - job: version-bump
      artifacts: true
  before_script:
    # Configure Git with CI_JOB_TOKEN authentication
    - |
      echo "ðŸ” Configuring Git authentication..."
      git config --global user.email "${GITLAB_USER_EMAIL:-ci@sinch.com}"
      git config --global user.name "${GITLAB_USER_NAME:-CI Release Bot}"
  script:
    # 1. create a fresh clone to avoid messing up the runner's cache or current workspace
    - git clone $CI_REPOSITORY_URL repo_to_sync
    - cd repo_to_sync

    # 2. Add the GitHub remote with the token embedded
    - |
      GITHUB_REPO_URL_CLEAN="${GITHUB_REPO_URL#https://}"
      GITHUB_REPO_URL_CLEAN="${GITHUB_REPO_URL_CLEAN#http://}"
      GITHUB_REPO_HOST_PART="${GITHUB_REPO_URL_CLEAN%%/*}"
      if [ "$GITHUB_REPO_HOST_PART" = "$GITHUB_REPO_URL_CLEAN" ]; then
        echo "ERROR: GITHUB_REPO_URL must be in the form org/repo, github.com/org/repo, or https://github.com/org/repo";
        exit 1;
      fi
      if [ "$GITHUB_REPO_HOST_PART" = "github.com" ]; then
        :
      elif echo "$GITHUB_REPO_HOST_PART" | grep -q '\\.'; then
        :
      else
        GITHUB_REPO_URL_CLEAN="github.com/${GITHUB_REPO_URL_CLEAN}"
      fi
      git remote add github "https://x-access-token:${GITHUB_PAT_2}@${GITHUB_REPO_URL_CLEAN}"

    # 3. Push default branch to GitHub
    - |
      TARGET_BRANCH="$CI_DEFAULT_BRANCH"
      echo "Syncing branch to GitHub: $TARGET_BRANCH"

      if [ -n "${RELEASE_COMMIT_SHA:-}" ]; then
        echo "Using release commit SHA: $RELEASE_COMMIT_SHA"
        git fetch --prune origin "$RELEASE_COMMIT_SHA" || true
        git fetch --prune origin "$TARGET_BRANCH"
        git checkout -B "$TARGET_BRANCH" "$RELEASE_COMMIT_SHA" || git checkout -B "$TARGET_BRANCH" "origin/$TARGET_BRANCH"
      else
        git fetch --prune origin "$TARGET_BRANCH"
        git checkout -B "$TARGET_BRANCH" "origin/$TARGET_BRANCH"
      fi
    # 4. Remove .gitlab-ci.yml from final GitHub repo
    - git rm --ignore-unmatch .gitlab-ci.yml
    - git commit --amend --no-edit
    - git push github "$TARGET_BRANCH" --force
  rules:
    - if: $CI_COMMIT_REF_NAME == $CI_DEFAULT_BRANCH && $VERSION_BUMP_TYPE != "none" && $CI_PIPELINE_SOURCE == "push"
    - if: $CI_COMMIT_REF_NAME == $CI_DEFAULT_BRANCH && $CI_PIPELINE_SOURCE == "web"

# ================================
# Stage 3 - Tag + Release (GitLab + GitHub)
# ================================
build_skills_artifacts:
  stage: release
  image: alpine:latest
  needs:
    - job: version-bump
      artifacts: true
  before_script:
    - apk add --no-cache git jq zip
  script:
    - git fetch --prune --tags origin "$CI_DEFAULT_BRANCH"

    # For republish (VERSION_BUMP_TYPE=none), build from the tag commit if the tag exists.
    - |
      checked_out=0
      if [ -n "${RELEASE_COMMIT_SHA:-}" ]; then
        echo "Building artifacts from release commit $RELEASE_COMMIT_SHA"
        git fetch --prune origin "$RELEASE_COMMIT_SHA" || true
        if git cat-file -e "$RELEASE_COMMIT_SHA^{commit}" > /dev/null 2>&1; then
          git checkout -qf "$RELEASE_COMMIT_SHA"
          checked_out=1
        else
          echo "WARNING: RELEASE_COMMIT_SHA not reachable; falling back to tag/branch checkout"
        fi
      fi

      if [ "$checked_out" != "1" ]; then
        if [ -n "${TAG_NAME:-}" ] && git ls-remote --exit-code --tags origin "refs/tags/$TAG_NAME" > /dev/null 2>&1; then
          echo "Building artifacts from existing tag $TAG_NAME"
          git fetch --tags origin
          git checkout -qf "$TAG_NAME"
        else
          git checkout -B "$CI_DEFAULT_BRANCH" "origin/$CI_DEFAULT_BRANCH"
        fi
      fi
    - mkdir -p dist
    - PLUGIN_FILE="plugins/sinch-claude-plugin/.claude-plugin/plugin.json"
    - CURRENT_VERSION=$(jq -r .version "$PLUGIN_FILE")

    - |
      if [ -n "${NEW_VERSION:-}" ] && [ "$CURRENT_VERSION" != "$NEW_VERSION" ]; then
        if [ "${VERSION_BUMP_TYPE:-}" != "none" ]; then
          echo "WARNING: plugin.json version ($CURRENT_VERSION) != NEW_VERSION ($NEW_VERSION); updating working copy for packaging."
          jq --arg v "$NEW_VERSION" '.version = $v' "$PLUGIN_FILE" > tmp.json && mv tmp.json "$PLUGIN_FILE"
          CURRENT_VERSION="$NEW_VERSION"
        else
          echo "ERROR: plugin.json version ($CURRENT_VERSION) != NEW_VERSION ($NEW_VERSION)."
          echo "Hint: use RELEASE_TAG_OVERRIDE / RELEASE_VERSION_OVERRIDE to republish older versions."
          exit 1
        fi
      fi

    - SKILLS_DIR="plugins/sinch-claude-plugin/skills"
    - VERSION_FOR_ZIP="${NEW_VERSION:-$CURRENT_VERSION}"
    - ZIP_VERSIONED="dist/sinch-claude-plugin-skills-${VERSION_FOR_ZIP}.zip"
    - |
      echo "Zipping skills folder: $SKILLS_DIR"
      if [ ! -d "$SKILLS_DIR" ]; then
        echo "ERROR: Skills directory not found: $SKILLS_DIR";
        exit 1;
      fi
      (cd "plugins/sinch-claude-plugin" && zip -r "../../$ZIP_VERSIONED" "skills")
  artifacts:
    expire_in: never
    reports:
      dotenv: skills.env
    paths:
      - dist/*.zip
  after_script:
    - |
      {
        echo "SKILLS_ARTIFACT_JOB_ID=$CI_JOB_ID";
      } > skills.env
  rules:
    - if: $CI_COMMIT_REF_NAME == $CI_DEFAULT_BRANCH && $VERSION_BUMP_TYPE != "none" && $CI_PIPELINE_SOURCE == "push"
    - if: $CI_COMMIT_REF_NAME == $CI_DEFAULT_BRANCH && $CI_PIPELINE_SOURCE == "web"

# ================================
# Stage 3 - Tag + Release (GitLab + GitHub)
# Split into small retryable jobs.
# ================================

gitlab_tag:
  stage: release
  image: alpine:latest
  needs:
    - job: version-bump
      artifacts: true
  resource_group: release-default-branch
  before_script:
    - apk add --no-cache git
    - |
      echo "ðŸ” Configuring Git authentication..."
      git config --global user.email "${GITLAB_USER_EMAIL:-ci@sinch.com}"
      git config --global user.name "${GITLAB_USER_NAME:-CI Release Bot}"
  script:
    - |
      if [ -z "${TAG_NAME:-}" ] || [ -z "${NEW_VERSION:-}" ]; then
        echo "ERROR: TAG_NAME/NEW_VERSION missing. Did version-bump export release.env?";
        exit 1;
      fi

      git remote set-url origin "https://gitlab-ci-token:${CI_JOB_TOKEN}@${CI_SERVER_HOST}/${CI_PROJECT_PATH}.git"
      git fetch --prune --tags origin "$CI_DEFAULT_BRANCH"

      if git ls-remote --exit-code --tags origin "refs/tags/$TAG_NAME" > /dev/null 2>&1; then
        echo "GitLab tag already exists: $TAG_NAME (will not move it)"
        exit 0
      fi

      if [ "$VERSION_BUMP_TYPE" = "none" ]; then
        echo "ERROR: Republish mode requires existing tag. Tag not found: $TAG_NAME"
        exit 1
      fi

      if [ -n "${RELEASE_COMMIT_SHA:-}" ]; then
        git fetch --prune origin "$RELEASE_COMMIT_SHA" || true
        if git cat-file -e "$RELEASE_COMMIT_SHA^{commit}" > /dev/null 2>&1; then
          git checkout -qf "$RELEASE_COMMIT_SHA"
        else
          echo "WARNING: RELEASE_COMMIT_SHA not reachable; tagging origin/$CI_DEFAULT_BRANCH instead"
          git checkout -B "$CI_DEFAULT_BRANCH" "origin/$CI_DEFAULT_BRANCH"
        fi
      else
        git checkout -B "$CI_DEFAULT_BRANCH" "origin/$CI_DEFAULT_BRANCH"
      fi
      echo "Creating GitLab tag: $TAG_NAME"
      git tag -a "$TAG_NAME" -m "$TAG_NAME"
      git push origin "$TAG_NAME"
  rules:
    - if: $CI_COMMIT_REF_NAME == $CI_DEFAULT_BRANCH && $VERSION_BUMP_TYPE != "none" && $CI_PIPELINE_SOURCE == "push"
    - if: $CI_COMMIT_REF_NAME == $CI_DEFAULT_BRANCH && $CI_PIPELINE_SOURCE == "web"

gitlab_release:
  stage: release
  image: registry.gitlab.com/gitlab-org/release-cli:latest
  needs:
    - job: version-bump
      artifacts: true
    - job: build_skills_artifacts
      artifacts: true
    - job: gitlab_tag
      artifacts: false
      optional: true
  script:
    - echo "Creating GitLab release for $TAG_NAME"
  release:
    tag_name: $TAG_NAME
    name: $TAG_NAME
    description: "Release $TAG_NAME"
    assets:
      links:
        - name: "sinch-claude-plugin-skills-${NEW_VERSION}.zip"
          url: "$CI_PROJECT_URL/-/jobs/$SKILLS_ARTIFACT_JOB_ID/artifacts/raw/dist/sinch-claude-plugin-skills-${NEW_VERSION}.zip"
  rules:
    - if: $CI_COMMIT_REF_NAME == $CI_DEFAULT_BRANCH && $VERSION_BUMP_TYPE != "none" && $CI_PIPELINE_SOURCE == "push"
    - if: $CI_COMMIT_REF_NAME == $CI_DEFAULT_BRANCH && $CI_PIPELINE_SOURCE == "web"

github_release_prepare:
  stage: release
  image: alpine:latest
  needs:
    - job: version-bump
      artifacts: true
    - job: sync_to_github
      artifacts: false
      optional: true
  resource_group: release-default-branch
  before_script:
    - apk add --no-cache git curl jq
    - |
      echo "ðŸ” Configuring Git authentication..."
      git config --global user.email "${GITLAB_USER_EMAIL:-ci@sinch.com}"
      git config --global user.name "${GITLAB_USER_NAME:-CI Release Bot}"
  script:
    - |
      if [ -z "${TAG_NAME:-}" ] || [ -z "${NEW_VERSION:-}" ]; then
        echo "ERROR: TAG_NAME/NEW_VERSION missing. Did version-bump export release.env?";
        exit 1;
      fi

      TARGET_BRANCH="$CI_DEFAULT_BRANCH"

      GITHUB_REPO_URL_CLEAN="${GITHUB_REPO_URL#https://}"
      GITHUB_REPO_URL_CLEAN="${GITHUB_REPO_URL_CLEAN#http://}"
      GITHUB_REPO_HOST_PART="${GITHUB_REPO_URL_CLEAN%%/*}"
      if [ "$GITHUB_REPO_HOST_PART" = "$GITHUB_REPO_URL_CLEAN" ]; then
        echo "ERROR: GITHUB_REPO_URL must be in the form org/repo, github.com/org/repo, or https://github.com/org/repo";
        exit 1;
      fi
      if [ "$GITHUB_REPO_HOST_PART" = "github.com" ]; then
        :
      elif echo "$GITHUB_REPO_HOST_PART" | grep -q '\\.'; then
        :
      else
        GITHUB_REPO_URL_CLEAN="github.com/${GITHUB_REPO_URL_CLEAN}"
      fi
      GITHUB_REPO_PATH="$GITHUB_REPO_URL_CLEAN"
      GITHUB_REPO_PATH="${GITHUB_REPO_PATH#github.com/}"
      GITHUB_REPO_PATH="${GITHUB_REPO_PATH%.git}"
      echo "GitHub repo path: $GITHUB_REPO_PATH"
      GITHUB_CLONE_URL="https://x-access-token:${GITHUB_PAT_2}@${GITHUB_REPO_URL_CLEAN}"
      # Ensure tag exists on GitHub if this is a bump pipeline; republish requires the tag to already exist.
      if git ls-remote --exit-code --tags "$GITHUB_CLONE_URL" "refs/tags/$TAG_NAME" > /dev/null 2>&1; then
        echo "GitHub tag already exists: $TAG_NAME"
      else
        if [ "$VERSION_BUMP_TYPE" = "none" ]; then
          echo "ERROR: Republish mode requires existing GitHub tag. Tag not found: $TAG_NAME"
          exit 1
        fi
        echo "Creating GitHub tag: $TAG_NAME on GitHub $TARGET_BRANCH HEAD"
        rm -rf repo_github
        git clone --depth 1 --branch "$TARGET_BRANCH" "$GITHUB_CLONE_URL" repo_github
        cd repo_github
        git tag -a "$TAG_NAME" -m "$TAG_NAME"
        git push origin "$TAG_NAME"
        cd ..
      fi

      API="https://api.github.com/repos/${GITHUB_REPO_PATH}"
      AUTH_HEADER="Authorization: Bearer ${GITHUB_PAT_2}"
      ACCEPT_HEADER="Accept: application/vnd.github+json"

      existing=$(curl -sS -H "$AUTH_HEADER" -H "$ACCEPT_HEADER" "$API/releases/tags/$TAG_NAME" || true)
      release_id=$(echo "$existing" | jq -r '.id // empty' 2>/dev/null || true)

      if [ -z "$release_id" ] || [ "$release_id" = "null" ]; then
        echo "Creating GitHub release for tag $TAG_NAME"
        payload=$(jq -n \
          --arg tag "$TAG_NAME" \
          --arg name "$TAG_NAME" \
          '{tag_name:$tag, name:$name, draft:false, prerelease:false}')
        created=$(curl -sS -X POST -H "$AUTH_HEADER" -H "$ACCEPT_HEADER" -H "Content-Type: application/json" \
          -d "$payload" "$API/releases")
        release_id=$(echo "$created" | jq -r '.id')
      else
        echo "GitHub release already exists for $TAG_NAME (id=$release_id)"
      fi

      if [ -z "$release_id" ] || [ "$release_id" = "null" ]; then
        echo "ERROR: Unable to determine GitHub release id";
        exit 1;
      fi

      {
        echo "GITHUB_REPO_PATH=$GITHUB_REPO_PATH";
        echo "GITHUB_RELEASE_ID=$release_id";
      } > github.env
  artifacts:
    reports:
      dotenv: github.env
  retry:
    max: 2
    when:
      - api_failure
      - runner_system_failure
      - unknown_failure
  rules:
    - if: $CI_COMMIT_REF_NAME == $CI_DEFAULT_BRANCH && $VERSION_BUMP_TYPE != "none" && $CI_PIPELINE_SOURCE == "push"
    - if: $CI_COMMIT_REF_NAME == $CI_DEFAULT_BRANCH && $CI_PIPELINE_SOURCE == "web"

github_upload_versioned_asset:
  stage: release
  image: alpine:latest
  needs:
    - job: version-bump
      artifacts: true
    - job: build_skills_artifacts
      artifacts: true
    - job: github_release_prepare
      artifacts: true
  before_script:
    - apk add --no-cache curl jq
  script:
    - ZIP_FILE="dist/sinch-claude-plugin-skills-${NEW_VERSION}.zip"
    - |
      if [ ! -f "$ZIP_FILE" ]; then
        echo "ERROR: Expected artifact not found: $ZIP_FILE";
        ls -la dist || true;
        exit 1;
      fi

      API="https://api.github.com/repos/${GITHUB_REPO_PATH}"
      AUTH_HEADER="Authorization: Bearer ${GITHUB_PAT_2}"
      ACCEPT_HEADER="Accept: application/vnd.github+json"

      assets=$(curl -sS -H "$AUTH_HEADER" -H "$ACCEPT_HEADER" "$API/releases/$GITHUB_RELEASE_ID/assets" || true)
      name=$(basename "$ZIP_FILE")
      existing_asset_id=$(echo "$assets" | jq -r --arg n "$name" '.[] | select(.name==$n) | .id' | head -n 1)

      if [ -n "$existing_asset_id" ] && [ "$existing_asset_id" != "null" ]; then
        echo "Asset already exists; skipping upload: $name"
        exit 0
      fi

      echo "Uploading GitHub asset: $name"
      curl -sS -X POST \
        -H "$AUTH_HEADER" \
        -H "$ACCEPT_HEADER" \
        -H "Content-Type: application/zip" \
        --data-binary "@$ZIP_FILE" \
        "https://uploads.github.com/repos/${GITHUB_REPO_PATH}/releases/${GITHUB_RELEASE_ID}/assets?name=${name}" > /dev/null
  retry:
    max: 2
    when:
      - api_failure
      - runner_system_failure
      - unknown_failure
  rules:
    - if: $CI_COMMIT_REF_NAME == $CI_DEFAULT_BRANCH && $VERSION_BUMP_TYPE != "none" && $CI_PIPELINE_SOURCE == "push"
    - if: $CI_COMMIT_REF_NAME == $CI_DEFAULT_BRANCH && $CI_PIPELINE_SOURCE == "web"
