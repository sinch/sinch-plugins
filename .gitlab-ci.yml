# yaml-language-server: $schema=https://gitlab.com/gitlab-org/gitlab/-/raw/master/app/assets/javascripts/editor/schema/ci.json
# ================================
# GitLab CI Variables Reference
# ================================
# Required variables (set in Settings â†’ CI/CD â†’ Variables):
#   GITHUB_PAT_2 - Personal Access Token with for synching with GitHub repos (MUST be kept secret)
#   GITHUB_REPO_URL - GitHub repository URL (e.g., github.com/sinch/sinch-plugins or https://github.com/sinch/sinch-plugins)
#
# Predefined GitLab CI variables (automatically available):
#   CI_COMMIT_SHORT_SHA   - Short commit SHA (first 8 chars)
#   CI_COMMIT_REF_NAME    - Branch or tag name
#   CI_COMMIT_REF_SLUG    - Branch name slugified for URLs
#   CI_COMMIT_TAG         - Git tag (if pipeline triggered by tag)
#   GITLAB_USER_EMAIL     - Email of user who triggered pipeline
#   GITLAB_USER_NAME      - Name of user who triggered pipeline
#   CI_PROJECT_URL        - GitLab project URL
#   CI_JOB_ID             - Unique job ID
#   CI_JOB_TOKEN          - GitLab job token (used for git authentication)
#   CI_SERVER_HOST        - GitLab server hostname (e.g., gitlab.com)
#   CI_PROJECT_PATH       - Project path (group/project)
# ================================
# Pipeline-level inputs specification
spec:
  inputs:
    version_bump_type:
      description: "Select which version bump to apply. Version bump type: patch (0.0.X), minor (0.X.0), major (X.0.0), or none (skip bump)"
      type: string
      default: "patch"
      options:
        - patch
        - minor
        - major
        - none
---
default:
  tags:
    - saas
    - general
    - eu-west-1
    # Arch is especially important
    - arm64

variables:
  # Make the pipeline input available in `rules:` and `script:` blocks.
  VERSION_BUMP_TYPE: $[[ inputs.version_bump_type ]]

stages:
  - pre-release
  - github-sync
  - release

# ================================
# Reusable Templates & Anchors
# ================================

# Common rules for release jobs:
# - push + bump: Normal release flow with version bump
# - web (any bump_type): Support republish flow - re-syncs existing version
.release_rules:
  rules:
    - if: $CI_COMMIT_REF_NAME == $CI_DEFAULT_BRANCH && $VERSION_BUMP_TYPE != "none" && $CI_PIPELINE_SOURCE == "push"
    - if: $CI_COMMIT_REF_NAME == $CI_DEFAULT_BRANCH && $CI_PIPELINE_SOURCE == "web"

# Rules for jobs that run on all triggers (including bump_type=none on push)
.all_triggers_rules:
  rules:
    - if: $CI_COMMIT_REF_NAME == $CI_DEFAULT_BRANCH && $CI_PIPELINE_SOURCE == "push"
    - if: $CI_COMMIT_REF_NAME == $CI_DEFAULT_BRANCH && $CI_PIPELINE_SOURCE == "web"

# Common Git configuration
.git_config:
  before_script:
    - |
      echo "ðŸ” Configuring Git authentication..."
      git config --global user.email "${GITLAB_USER_EMAIL:-ci@sinch.com}"
      git config --global user.name "${GITLAB_USER_NAME:-CI Release Bot}"

# Common retry configuration for network/API operations
.retry_config:
  retry:
    max: 2
    when:
      - api_failure
      - runner_system_failure
      - unknown_failure

# GitHub URL parsing script (reusable anchor)
.parse_github_url_script: &parse_github_url_script |
  GITHUB_REPO_URL_CLEAN="${GITHUB_REPO_URL#https://}"
  GITHUB_REPO_URL_CLEAN="${GITHUB_REPO_URL_CLEAN#http://}"
  GITHUB_REPO_HOST_PART="${GITHUB_REPO_URL_CLEAN%%/*}"
  if [ "$GITHUB_REPO_HOST_PART" = "$GITHUB_REPO_URL_CLEAN" ]; then
    echo "ERROR: GITHUB_REPO_URL must be in the form org/repo, github.com/org/repo, or https://github.com/org/repo";
    exit 1;
  fi
  if [ "$GITHUB_REPO_HOST_PART" = "github.com" ]; then
    :
  elif echo "$GITHUB_REPO_HOST_PART" | grep -q '\.'; then
    :
  else
    GITHUB_REPO_URL_CLEAN="github.com/${GITHUB_REPO_URL_CLEAN}"
  fi

# ================================
# Stage 1 - Bump Version
# ================================
version-bump:
  stage: pre-release
  image: alpine:latest
  timeout: 10 minutes
  before_script:
    - apk add --no-cache git jq
    - |
      echo "ðŸ” Configuring Git authentication..."
      git config --global user.email "${GITLAB_USER_EMAIL:-ci@sinch.com}"
      git config --global user.name "${GITLAB_USER_NAME:-CI Release Bot}"
  script:
    - BUMP_TYPE="$VERSION_BUMP_TYPE"
    - echo "Bump type is $BUMP_TYPE"
    - |
      if [ "$BUMP_TYPE" = "none" ]; then
        echo "Skipping version bump; computing release context for republish"

        PLUGIN_FILE="plugins/sinch-claude-plugin/.claude-plugin/plugin.json"
        MARKETPLACE_FILE=".claude-plugin/marketplace.json"
        PLUGIN_NAME="sinch-claude-plugin"
        GEMINI_FILE="plugins/sinch-gemini-extension/gemini-extension.json"

        # Ensure we can read from default branch even if this is a web pipeline.
        git fetch --prune --tags origin "$CI_DEFAULT_BRANCH" || true

        DEFAULT_PLUGIN_JSON="$(git show "origin/$CI_DEFAULT_BRANCH:$PLUGIN_FILE" 2>/dev/null || cat "$PLUGIN_FILE")"
        DEFAULT_MARKETPLACE_JSON="$(git show "origin/$CI_DEFAULT_BRANCH:$MARKETPLACE_FILE" 2>/dev/null || cat "$MARKETPLACE_FILE")"
        DEFAULT_GEMINI_JSON="$(git show "origin/$CI_DEFAULT_BRANCH:$GEMINI_FILE" 2>/dev/null || cat "$GEMINI_FILE")"

        DEFAULT_PLUGIN_VERSION="$(echo "$DEFAULT_PLUGIN_JSON" | jq -r .version)"
        DEFAULT_GEMINI_VERSION="$(echo "$DEFAULT_GEMINI_JSON" | jq -r .version)"

        MATCH_COUNT="$(echo "$DEFAULT_MARKETPLACE_JSON" | jq -r --arg name "$PLUGIN_NAME" '[.plugins[] | select(.name == $name)] | length')"
        if [ "$MATCH_COUNT" != "1" ]; then
          echo "ERROR: marketplace.json must contain exactly one plugin named '$PLUGIN_NAME' (found $MATCH_COUNT)."
          exit 1
        fi

        DEFAULT_MARKETPLACE_PLUGIN_VERSION="$(echo "$DEFAULT_MARKETPLACE_JSON" | jq -r --arg name "$PLUGIN_NAME" '.plugins[] | select(.name == $name) | .version')"
        if [ "$DEFAULT_PLUGIN_VERSION" != "$DEFAULT_MARKETPLACE_PLUGIN_VERSION" ]; then
          echo "ERROR: version drift on default branch: plugin.json ($DEFAULT_PLUGIN_VERSION) != marketplace plugin entry ($DEFAULT_MARKETPLACE_PLUGIN_VERSION)."
          exit 1
        fi

        # Validate Gemini version matches Claude version
        if [ "$DEFAULT_PLUGIN_VERSION" != "$DEFAULT_GEMINI_VERSION" ]; then
          echo "ERROR: version drift on default branch: plugin.json ($DEFAULT_PLUGIN_VERSION) != gemini-extension.json ($DEFAULT_GEMINI_VERSION)."
          exit 1
        fi

        NEW_VERSION="$DEFAULT_PLUGIN_VERSION"
        TAG_NAME="sinch-plugins-v${NEW_VERSION}"

        if [ -z "$NEW_VERSION" ] || [ "$NEW_VERSION" = "null" ] || [ -z "$TAG_NAME" ]; then
          echo "ERROR: unable to compute NEW_VERSION/TAG_NAME for republish."
          exit 1
        fi

        # Require tag to exist for republish
        RELEASE_COMMIT_SHA=""
        if ! git ls-remote --exit-code --tags origin "refs/tags/$TAG_NAME" > /dev/null 2>&1; then
          echo "ERROR: Republish mode requires existing tag. Tag not found: $TAG_NAME"
          exit 1
        fi
        git fetch --tags origin || true
        RELEASE_COMMIT_SHA="$(git rev-list -n 1 "$TAG_NAME" 2>/dev/null || true)"

        {
          echo "NEW_VERSION=${NEW_VERSION}";
          echo "TAG_NAME=${TAG_NAME}";
          if [ -n "$RELEASE_COMMIT_SHA" ]; then echo "RELEASE_COMMIT_SHA=${RELEASE_COMMIT_SHA}"; fi
        } > release.env
        exit 0
      fi

    # Set up Git credentials using GitLab's CI_JOB_TOKEN with write access
    # Note: Requires Settings -> CI/CD -> Job Token Permissions -> Allow Git push requests to the repository
    - |
      git remote set-url origin "https://gitlab-ci-token:${CI_JOB_TOKEN}@${CI_SERVER_HOST}/${CI_PROJECT_PATH}.git"
      git checkout $CI_COMMIT_REF_NAME
      git pull origin $CI_COMMIT_REF_NAME

    - PLUGIN_FILE="plugins/sinch-claude-plugin/.claude-plugin/plugin.json"
    - MARKETPLACE_FILE=".claude-plugin/marketplace.json"
    - PLUGIN_NAME="sinch-claude-plugin"
    - GEMINI_FILE="plugins/sinch-gemini-extension/gemini-extension.json"
    - CURRENT_VERSION=$(jq -r .version $PLUGIN_FILE)
    - echo "Current version $CURRENT_VERSION"

    - |
      MATCH_COUNT=$(jq -r --arg name "$PLUGIN_NAME" '[.plugins[] | select(.name == $name)] | length' "$MARKETPLACE_FILE")
      if [ "$MATCH_COUNT" != "1" ]; then
        echo "ERROR: marketplace.json must contain exactly one plugin named '$PLUGIN_NAME' (found $MATCH_COUNT)."
        exit 1
      fi
      MARKETPLACE_PLUGIN_VERSION=$(jq -r --arg name "$PLUGIN_NAME" '.plugins[] | select(.name == $name) | .version' "$MARKETPLACE_FILE")
      if [ "$MARKETPLACE_PLUGIN_VERSION" != "$CURRENT_VERSION" ]; then
        echo "ERROR: version drift: plugin.json ($CURRENT_VERSION) != marketplace plugin entry ($MARKETPLACE_PLUGIN_VERSION)."
        exit 1
      fi

    # Validate Gemini extension version matches Claude plugin version
    - |
      GEMINI_VERSION=$(jq -r .version "$GEMINI_FILE")
      if [ "$GEMINI_VERSION" != "$CURRENT_VERSION" ]; then
        echo "ERROR: version drift: plugin.json ($CURRENT_VERSION) != gemini-extension.json ($GEMINI_VERSION)."
        exit 1
      fi
      echo "Gemini extension version: $GEMINI_VERSION (synchronized)"

    - |
      major=$(echo "$CURRENT_VERSION" | cut -d. -f1)
      minor=$(echo "$CURRENT_VERSION" | cut -d. -f2)
      patch=$(echo "$CURRENT_VERSION" | cut -d. -f3)
      if [ "$BUMP_TYPE" = "major" ]; then
        major=$((major + 1)); minor=0; patch=0
      elif [ "$BUMP_TYPE" = "minor" ]; then
        minor=$((minor + 1)); patch=0
      else
        patch=$((patch + 1))
      fi
      NEW_VERSION="$major.$minor.$patch"
      echo "New version: $NEW_VERSION"
      echo "$NEW_VERSION" > version.txt

    - NEW_VERSION=$(cat version.txt)
    - jq --indent 2 --arg v "$NEW_VERSION" '.version = $v' $PLUGIN_FILE > tmp.json && mv tmp.json $PLUGIN_FILE
    - |
      jq --indent 4 \
        --arg name "$PLUGIN_NAME" \
        --arg v "$NEW_VERSION" \
        '.plugins |= map(if .name == $name then (.version = $v) else . end)' \
        "$MARKETPLACE_FILE" > tmp.marketplace.json
      mv tmp.marketplace.json "$MARKETPLACE_FILE"

    # Update Gemini extension version
    - jq --indent 2 --arg v "$NEW_VERSION" '.version = $v' $GEMINI_FILE > tmp.gemini.json && mv tmp.gemini.json $GEMINI_FILE

    - git add $PLUGIN_FILE $MARKETPLACE_FILE $GEMINI_FILE
    - |
      git commit -m "ci(release): ${NEW_VERSION} [skip ci]"

      RELEASE_COMMIT_SHA="$(git rev-parse HEAD)"
      TAG_NAME="sinch-plugins-v${NEW_VERSION}"
      {
        echo "NEW_VERSION=${NEW_VERSION}";
        echo "TAG_NAME=${TAG_NAME}";
        echo "RELEASE_COMMIT_SHA=${RELEASE_COMMIT_SHA}";
      } > release.env

      git push origin HEAD:$CI_COMMIT_REF_NAME
  artifacts:
    reports:
      dotenv: release.env
  extends:
    - .all_triggers_rules

# ================================
# Stage 2 - Sync default branch to GitHub
# ================================
# We only using git push [$CI_DEFAULT_BRANCH] --force here instead of a full mirror push to avoid
# cloning internal branches or tags that are not meant to be pushed to GitHub.
sync_to_github:
  stage: github-sync
  image:
    name: alpine/git:latest
    entrypoint: [""]
  timeout: 10 minutes
  needs:
    - job: version-bump
      artifacts: true
  extends:
    - .git_config
    - .retry_config
    - .release_rules
  script:
    # 1. create a fresh clone to avoid messing up the runner's cache or current workspace
    - git clone $CI_REPOSITORY_URL repo_to_sync
    - cd repo_to_sync

    # 2. Add the GitHub remote with the token embedded
    - *parse_github_url_script
    - git remote add github "https://x-access-token:${GITHUB_PAT_2}@${GITHUB_REPO_URL_CLEAN}"

    # 3. Push default branch to GitHub
    - |
      TARGET_BRANCH="$CI_DEFAULT_BRANCH"
      echo "Syncing branch to GitHub: $TARGET_BRANCH"

      if [ -n "${RELEASE_COMMIT_SHA:-}" ]; then
        echo "Using release commit SHA: $RELEASE_COMMIT_SHA"
        git fetch --prune origin "$RELEASE_COMMIT_SHA" || true
        git fetch --prune origin "$TARGET_BRANCH"
        git checkout -B "$TARGET_BRANCH" "$RELEASE_COMMIT_SHA" || git checkout -B "$TARGET_BRANCH" "origin/$TARGET_BRANCH"
      else
        git fetch --prune origin "$TARGET_BRANCH"
        git checkout -B "$TARGET_BRANCH" "origin/$TARGET_BRANCH"
      fi
    # 4. Remove .gitlab-ci.yml from final GitHub repo
    - git rm --ignore-unmatch .gitlab-ci.yml
    # Only amend if there are staged changes (file was actually removed)
    - |
      if git diff --cached --quiet; then
        echo "No changes to commit (file already removed or doesn't exist)"
      else
        git commit --amend --no-edit
      fi
    - git push github "$TARGET_BRANCH" --force

# ================================
# Stage 3 - Tag + Release (GitLab + GitHub)
# Split into small retryable jobs.
# ================================

build_artifacts:
  stage: release
  image: alpine:latest
  timeout: 10 minutes
  needs:
    - job: version-bump
      artifacts: true
  extends:
    - .release_rules
  before_script:
    - apk add --no-cache git jq zip
  script:
    - git fetch --prune --tags origin "$CI_DEFAULT_BRANCH"

    # For republish (VERSION_BUMP_TYPE=none), build from the tag commit if the tag exists.
    - |
      checked_out=0
      if [ -n "${RELEASE_COMMIT_SHA:-}" ]; then
        echo "Building artifacts from release commit $RELEASE_COMMIT_SHA"
        git fetch --prune origin "$RELEASE_COMMIT_SHA" || true
        if git cat-file -e "$RELEASE_COMMIT_SHA^{commit}" > /dev/null 2>&1; then
          git checkout -qf "$RELEASE_COMMIT_SHA"
          checked_out=1
        else
          echo "WARNING: RELEASE_COMMIT_SHA not reachable; falling back to tag/branch checkout"
        fi
      fi

      if [ "$checked_out" != "1" ]; then
        if [ -n "${TAG_NAME:-}" ] && git ls-remote --exit-code --tags origin "refs/tags/$TAG_NAME" > /dev/null 2>&1; then
          echo "Building artifacts from existing tag $TAG_NAME"
          git fetch --tags origin
          git checkout -qf "$TAG_NAME"
        else
          git checkout -B "$CI_DEFAULT_BRANCH" "origin/$CI_DEFAULT_BRANCH"
        fi
      fi
    - mkdir -p dist
    - PLUGIN_FILE="plugins/sinch-claude-plugin/.claude-plugin/plugin.json"
    - CURRENT_VERSION=$(jq -r .version "$PLUGIN_FILE")

    - |
      if [ -n "${NEW_VERSION:-}" ] && [ "$CURRENT_VERSION" != "$NEW_VERSION" ]; then
        if [ "${VERSION_BUMP_TYPE:-}" != "none" ]; then
          echo "WARNING: plugin.json version ($CURRENT_VERSION) != NEW_VERSION ($NEW_VERSION); updating working copy for packaging."
          jq --arg v "$NEW_VERSION" '.version = $v' "$PLUGIN_FILE" > tmp.json && mv tmp.json "$PLUGIN_FILE"
          CURRENT_VERSION="$NEW_VERSION"
        else
          echo "ERROR: plugin.json version ($CURRENT_VERSION) != NEW_VERSION ($NEW_VERSION)."
          echo "Hint: republish builds from an existing tag matching NEW_VERSION; ensure the tag exists and matches plugin.json."
          exit 1
        fi
      fi

    - SKILLS_DIR="plugins/sinch-claude-plugin/skills"
    - VERSION_FOR_ZIP="${NEW_VERSION:-$CURRENT_VERSION}"
    - ZIP_VERSIONED="dist/sinch-agent-skills-${VERSION_FOR_ZIP}.zip"
    - |
      echo "Zipping skills folder: $SKILLS_DIR"
      if [ ! -d "$SKILLS_DIR" ]; then
        echo "ERROR: Skills directory not found: $SKILLS_DIR";
        exit 1;
      fi
      (cd "plugins/sinch-claude-plugin" && zip -r "../../$ZIP_VERSIONED" "skills")

    # Build Gemini extension archive
    - GEMINI_DIR="plugins/sinch-gemini-extension"
    - GEMINI_ZIP="dist/sinch-gemini-extension-${VERSION_FOR_ZIP}.zip"
    - |
      echo "Zipping Gemini extension folder: $GEMINI_DIR"
      if [ ! -d "$GEMINI_DIR" ]; then
        echo "ERROR: Gemini extension directory not found: $GEMINI_DIR";
        exit 1;
      fi
      # Ensure gemini-extension.json has correct version
      GEMINI_FILE="$GEMINI_DIR/gemini-extension.json"
      GEMINI_VERSION=$(jq -r .version "$GEMINI_FILE")
      if [ -n "${NEW_VERSION:-}" ] && [ "$GEMINI_VERSION" != "$NEW_VERSION" ]; then
        if [ "${VERSION_BUMP_TYPE:-}" != "none" ]; then
          echo "WARNING: gemini-extension.json version ($GEMINI_VERSION) != NEW_VERSION ($NEW_VERSION); updating for packaging."
          jq --indent 2 --arg v "$NEW_VERSION" '.version = $v' "$GEMINI_FILE" > tmp.gemini.json && mv tmp.gemini.json "$GEMINI_FILE"
        else
          echo "ERROR: gemini-extension.json version ($GEMINI_VERSION) != NEW_VERSION ($NEW_VERSION)."
          exit 1
        fi
      fi
      # Create zip with extension contents at root (gemini-extension.json must be at root of archive)
      (cd "$GEMINI_DIR" && zip -r "../../$GEMINI_ZIP" .)
    # Write artifacts.env in script (not after_script) so dotenv artifact is collected
    - |
      {
        echo "ARTIFACTS_JOB_ID=$CI_JOB_ID";
      } > artifacts.env
  artifacts:
    expire_in: never
    reports:
      dotenv: artifacts.env
    paths:
      - dist/*.zip

gitlab_tag:
  stage: release
  image: alpine:latest
  timeout: 5 minutes
  needs:
    - job: version-bump
      artifacts: true
  resource_group: release-default-branch
  extends:
    - .git_config
    - .retry_config
    - .release_rules
  before_script:
    - apk add --no-cache git
    - !reference [.git_config, before_script]
  script:
    - |
      if [ -z "${TAG_NAME:-}" ] || [ -z "${NEW_VERSION:-}" ]; then
        echo "ERROR: TAG_NAME/NEW_VERSION missing. Did version-bump export release.env?";
        exit 1;
      fi

      git remote set-url origin "https://gitlab-ci-token:${CI_JOB_TOKEN}@${CI_SERVER_HOST}/${CI_PROJECT_PATH}.git"
      git fetch --prune --tags origin "$CI_DEFAULT_BRANCH"

      if git ls-remote --exit-code --tags origin "refs/tags/$TAG_NAME" > /dev/null 2>&1; then
        echo "GitLab tag already exists: $TAG_NAME (will not move it)"
        exit 0
      fi

      if [ "$VERSION_BUMP_TYPE" = "none" ]; then
        echo "ERROR: Republish mode requires existing tag. Tag not found: $TAG_NAME"
        exit 1
      fi

      if [ -n "${RELEASE_COMMIT_SHA:-}" ]; then
        git fetch --prune origin "$RELEASE_COMMIT_SHA" || true
        if git cat-file -e "$RELEASE_COMMIT_SHA^{commit}" > /dev/null 2>&1; then
          git checkout -qf "$RELEASE_COMMIT_SHA"
        else
          echo "WARNING: RELEASE_COMMIT_SHA not reachable; tagging origin/$CI_DEFAULT_BRANCH instead"
          git checkout -B "$CI_DEFAULT_BRANCH" "origin/$CI_DEFAULT_BRANCH"
        fi
      else
        git checkout -B "$CI_DEFAULT_BRANCH" "origin/$CI_DEFAULT_BRANCH"
      fi
      echo "Creating GitLab tag: $TAG_NAME"
      git tag -a "$TAG_NAME" -m "$TAG_NAME"
      git push origin "$TAG_NAME"

gitlab_release:
  stage: release
  image: registry.gitlab.com/gitlab-org/release-cli:latest
  timeout: 5 minutes
  # Override runner tags to use default shared runners for release-cli
  tags:
    - default
  needs:
    - job: version-bump
      artifacts: true
    - job: build_artifacts
      artifacts: true
    - job: gitlab_tag
      artifacts: false
      optional: true
  extends:
    - .retry_config
    - .release_rules
  script:
    - echo "Creating GitLab release for $TAG_NAME"
  release:
    tag_name: $TAG_NAME
    name: "Release v${NEW_VERSION}"
    description: "Sinch Plugins v${NEW_VERSION} - includes sinch-claude-plugin skills and sinch-gemini-extension"
    assets:
      links:
        - name: "sinch-agent-skills-${NEW_VERSION}.zip"
          url: "$CI_PROJECT_URL/-/jobs/$ARTIFACTS_JOB_ID/artifacts/raw/dist/sinch-agent-skills-${NEW_VERSION}.zip"
        - name: "sinch-gemini-extension-${NEW_VERSION}.zip"
          url: "$CI_PROJECT_URL/-/jobs/$ARTIFACTS_JOB_ID/artifacts/raw/dist/sinch-gemini-extension-${NEW_VERSION}.zip"
  allow_failure: true

github_release_prepare:
  stage: release
  image: alpine:latest
  timeout: 10 minutes
  needs:
    - job: version-bump
      artifacts: true
    - job: sync_to_github
      artifacts: false
      optional: true
  resource_group: release-default-branch
  extends:
    - .git_config
    - .retry_config
    - .release_rules
  before_script:
    - apk add --no-cache git curl jq
    - !reference [.git_config, before_script]
  script:
    - |
      if [ -z "${TAG_NAME:-}" ] || [ -z "${NEW_VERSION:-}" ]; then
        echo "ERROR: TAG_NAME/NEW_VERSION missing. Did version-bump export release.env?";
        exit 1;
      fi

      TARGET_BRANCH="$CI_DEFAULT_BRANCH"
    - *parse_github_url_script
    - |
      GITHUB_REPO_PATH="$GITHUB_REPO_URL_CLEAN"
      GITHUB_REPO_PATH="${GITHUB_REPO_PATH#github.com/}"
      GITHUB_REPO_PATH="${GITHUB_REPO_PATH%.git}"
      echo "GitHub repo path: $GITHUB_REPO_PATH"
      GITHUB_CLONE_URL="https://x-access-token:${GITHUB_PAT_2}@${GITHUB_REPO_URL_CLEAN}"
      # Ensure tag exists on GitHub if this is a bump pipeline; republish requires the tag to already exist.
      if git ls-remote --exit-code --tags "$GITHUB_CLONE_URL" "refs/tags/$TAG_NAME" > /dev/null 2>&1; then
        echo "GitHub tag already exists: $TAG_NAME"
      else
        if [ "$VERSION_BUMP_TYPE" = "none" ]; then
          echo "ERROR: Republish mode requires existing GitHub tag. Tag not found: $TAG_NAME"
          exit 1
        fi
        echo "Creating GitHub tag: $TAG_NAME on GitHub $TARGET_BRANCH HEAD"
        rm -rf repo_github
        git clone --depth 1 --branch "$TARGET_BRANCH" "$GITHUB_CLONE_URL" repo_github
        cd repo_github
        git tag -a "$TAG_NAME" -m "$TAG_NAME"
        git push origin "$TAG_NAME"
        cd ..
      fi

      API="https://api.github.com/repos/${GITHUB_REPO_PATH}"
      AUTH_HEADER="Authorization: Bearer ${GITHUB_PAT_2}"
      ACCEPT_HEADER="Accept: application/vnd.github+json"

      existing=$(curl -sS -H "$AUTH_HEADER" -H "$ACCEPT_HEADER" "$API/releases/tags/$TAG_NAME" || true)
      release_id=$(echo "$existing" | jq -r '.id // empty' 2>/dev/null || true)

      if [ -z "$release_id" ] || [ "$release_id" = "null" ]; then
        echo "Creating GitHub release for tag $TAG_NAME"
        payload=$(jq -n \
          --arg tag "$TAG_NAME" \
          --arg name "Sinch Plugins v${NEW_VERSION}" \
          --arg body "Sinch Plugins v${NEW_VERSION}\n\nIncludes:\n- sinch-agent-skills (Claude Code plugin skills)\n- sinch-gemini-extension (Gemini CLI extension)" \
          '{tag_name:$tag, name:$name, body:$body, draft:false, prerelease:false, make_latest:"true"}')
        created=$(curl -sS -X POST -H "$AUTH_HEADER" -H "$ACCEPT_HEADER" -H "Content-Type: application/json" \
          -d "$payload" "$API/releases")
        release_id=$(echo "$created" | jq -r '.id')
      else
        echo "GitHub release already exists for $TAG_NAME (id=$release_id)"
        # Update the release to mark it as latest
        echo "Marking release as latest..."
        curl -sS -X PATCH -H "$AUTH_HEADER" -H "$ACCEPT_HEADER" -H "Content-Type: application/json" \
          -d '{"make_latest":"true"}' "$API/releases/$release_id" > /dev/null || true
      fi

      if [ -z "$release_id" ] || [ "$release_id" = "null" ]; then
        echo "ERROR: Unable to determine GitHub release id";
        exit 1;
      fi

      {
        echo "GITHUB_REPO_PATH=$GITHUB_REPO_PATH";
        echo "GITHUB_RELEASE_ID=$release_id";
      } > github.env
  artifacts:
    reports:
      dotenv: github.env

github_upload_versioned_asset:
  stage: release
  image: alpine:latest
  timeout: 10 minutes
  needs:
    - job: version-bump
      artifacts: true
    - job: build_artifacts
      artifacts: true
    - job: github_release_prepare
      artifacts: true
  extends:
    - .retry_config
    - .release_rules
  before_script:
    - apk add --no-cache curl jq
  script:
    - |
      API="https://api.github.com/repos/${GITHUB_REPO_PATH}"
      AUTH_HEADER="Authorization: Bearer ${GITHUB_PAT_2}"
      ACCEPT_HEADER="Accept: application/vnd.github+json"

      # Upload both zip files
      for ZIP_FILE in "dist/sinch-agent-skills-${NEW_VERSION}.zip" "dist/sinch-gemini-extension-${NEW_VERSION}.zip"; do
        if [ ! -f "$ZIP_FILE" ]; then
          echo "ERROR: Expected artifact not found: $ZIP_FILE";
          ls -la dist || true;
          exit 1;
        fi

        assets=$(curl -sS -H "$AUTH_HEADER" -H "$ACCEPT_HEADER" "$API/releases/$GITHUB_RELEASE_ID/assets" || true)
        name=$(basename "$ZIP_FILE")
        existing_asset_id=$(echo "$assets" | jq -r --arg n "$name" '.[] | select(.name==$n) | .id' | head -n 1)

        if [ -n "$existing_asset_id" ] && [ "$existing_asset_id" != "null" ]; then
          echo "Asset already exists; skipping upload: $name"
        else
          echo "Uploading GitHub asset: $name"
          curl -sS -X POST \
            -H "$AUTH_HEADER" \
            -H "$ACCEPT_HEADER" \
            -H "Content-Type: application/zip" \
            --data-binary "@$ZIP_FILE" \
            "https://uploads.github.com/repos/${GITHUB_REPO_PATH}/releases/${GITHUB_RELEASE_ID}/assets?name=${name}" > /dev/null
        fi
      done
